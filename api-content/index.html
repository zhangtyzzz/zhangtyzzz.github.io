{"posts":[{"title":"背包问题总结","content":"1. 0-1背包问题[1] 容量为VVV的背包，有NNN件物品，每个物品的价值分别为WiW_iWi​，占用空间为CiC_iCi​，如何放可以使价值总和最大 状态转移方程： F[i,v]=max⁡{F[i−1,v],F[i−1,v−Ci]+Wi}F [ i , v ] = \\operatorname { max } \\{ F [ i - 1 , v ] , F [ i - 1 , v - C _ { i } ] + W _ { i } \\} F[i,v]=max{F[i−1,v],F[i−1,v−Ci​]+Wi​} F[i,v]F[i,v]F[i,v]表示把前iii件放到容量为vvv的背包里可以获得的最大价值，可以分为两种情况分析 如果放了第i件物品，那么F[i,v]=F[i−1,v−Ci]+WiF[i,v] = F[i-1,v-C_i]+W_iF[i,v]=F[i−1,v−Ci​]+Wi​，也就是把问题转换为前i−1i-1i−1件，放在容量为v−Civ-C_iv−Ci​的背包里的最大价值，加上第i件的价值。 如果不放第i件物品，那么F[i,v]=F[i−1,v]F[i,v] = F[i-1,v]F[i,v]=F[i−1,v]，问题变为前i−1i-1i−1件，放在容量为vvv的背包里 因为要取最大价值，所以取二者间更大的一种方案 伪代码： F[0,0..V]←0 for i←1 to N for v←Ci to VF[i,v]←max⁡{F[i−1,v],F[i−1,v−Ci]+Wi}\\left. \\begin{array} { l } { F [ 0,0 . . V ] \\leftarrow 0 } \\\\ { \\text { for } i \\leftarrow 1 \\text { to } N } \\\\ { \\quad\\text { for } v \\leftarrow C _ { i } \\text { to } V } \\\\ { \\qquad F [ i , v ] \\leftarrow \\operatorname { max } \\{ F [ i - 1 , v ] , F [ i - 1 , v - C _ { i } ] + W _ { i } \\} } \\end{array} \\right. F[0,0..V]←0 for i←1 to N for v←Ci​ to VF[i,v]←max{F[i−1,v],F[i−1,v−Ci​]+Wi​}​ 例题及python代码： 在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i] class Solution: &quot;&quot;&quot; @param m: An integer m denotes the size of a backpack @param A: Given n items with size A[i] @return: The maximum size &quot;&quot;&quot; def backPack(self, m, A): dp = [[0]*(len(A)+1) for i in range(m+1)] for j,data in enumerate(A): # i is current size for i in range(1, m + 1): if i&gt;= data: # j is from 0 to len(A)-1 # in our array dp[i][1] means use first item # so here use j+1 dp[i][j+1] = max(dp[i][j],dp[i-data][j]+data) else: dp[i][j+1] = dp[i][j] return dp[-1][-1] 优化空间复杂度 使用一个一维数组F[0…VF[0\\dotso VF[0…V实现优化 在例题中，假如背包大小为5，物品大小为3、4、2，列出表格如下 size 0 1 2 3 4 5 3 0 0 0 3 3 3 4 0 0 0 3 4 4 2 0 0 0 3 4 5 以物品大小为4，背包大小为5举例，我们会参考物品大小为3、背包大小为5和物品大小为3、背包大小为5-4=1的格子，也就是说我们在更新数据的时候参考的是上一行的以及左边的数据。那么我们可以使用一个一维数组存储之前的状态，在更新时，直接在当前的数组基础上更新。由于我们参考了左边的数据，所以我们在更新数据时，要从右向左更新，否则更新到后面的时候，前面的数据就不再是之前的状态，而是更新后的数据，就会出现错误。也可以理解为倒序是为了保证第i 次循环中的状态F[i,v]F[i,v]F[i,v]是由状态F[i−1,v−Ci]F[i-1,v- C_i]F[i−1,v−Ci​] 递推而来，这可以保证每件物品只选一次。 伪代码： F[0…V]←0 for i←1 to N for v←V to CiF[v]←max⁡{F[v],F[v−Ci]+Wi}\\left. \\begin{array} { l } { F [ 0 \\ldots V ] \\leftarrow 0 } \\\\ { \\text { for } i \\leftarrow 1 \\text { to } N } \\\\ { \\quad \\left. \\begin{array}{l}{ \\text { for } v \\leftarrow V \\text { to } C _ { i } }\\\\{\\qquad F [ v ] \\leftarrow \\operatorname { max } \\{ F [ v ] , F [ v - C _ { i } ] + W _ { i } \\} }\\end{array} \\right. } \\end{array} \\right. F[0…V]←0 for i←1 to N for v←V to Ci​F[v]←max{F[v],F[v−Ci​]+Wi​}​​ python代码 class Solution: &quot;&quot;&quot; @param m: An integer m denotes the size of a backpack @param A: Given n items with size A[i] @return: The maximum size &quot;&quot;&quot; def backPack(self, m, A): # size from 0 to m dp = [0 for i in range(m+1)] # first time just use item 1 # second time based of first time for data in A: for i in range(m, 0, -1): if i&gt;= data: # dp[i-data],dp[i] use new item or not dp[i] = max(dp[i],dp[i-data]+data) return dp[-1] 2. 完全背包问题 有NNN 种物品和一个容量为VVV 的背包，每种物品都有无限件可用。放入第iii 种物品 的费用是CiC_iCi​，价值是WiW_iWi​。求解：将哪些物品装入背包，可使这些物品的耗费的费用总 和不超过背包容量，且价值总和最大。 由于每种物品有无限件，所以它可以取0 ⁣⋯V/Ci0\\dotsi V/C_i0⋯V/Ci​件，采取之前01背包的思路来写状态转移方程： F[i,v]=max⁡{F[i−1,v−kCi]+kWi∣0≤kCi≤v}F [ i , v ] = \\operatorname { max } \\{ F [ i - 1 , v - k C _ { i } ] + k W _ { i } | 0 \\leq k C _ { i } \\leq v \\} F[i,v]=max{F[i−1,v−kCi​]+kWi​∣0≤kCi​≤v} 求解状态F[i,v]F[i,v]F[i,v] 的时间是O(vCi)O(\\frac{v}{C_i})O(Ci​v​)，总的复杂度可以认为是O(NV∑VCi)O(NV\\sum \\frac{V}{C_i})O(NV∑Ci​V​)，是比较大的。 O(VN)O(VN)O(VN)的算法 伪代码 F[0..V]←0 for i←1 to N for v←Ci to VF[v]←max⁡(F[v],F[v−Ci]+Wi)\\left. \\begin{array} { l } { F [ 0 . . V ] \\leftarrow 0 } \\\\ { \\text { for } i \\leftarrow 1 \\text { to } N } \\\\ { \\quad \\left. \\begin{array}{l}{ \\text { for } v \\leftarrow C _ { i } \\text { to } V }\\\\{\\qquad F [ v ] \\leftarrow \\operatorname { max } ( F [ v ] , F [ v - C _ { i } ] + W _ { i } ) }\\end{array} \\right. } \\end{array} \\right. F[0..V]←0 for i←1 to N for v←Ci​ to VF[v]←max(F[v],F[v−Ci​]+Wi​)​​ 与01背包优化空间复杂度后的代码区别仅有vvv的循环次序不同，之前01背包中倒序的原因是为了保证每个物品只能被选择一次，如果正序，每件物品可以被选择多次，现在需要的正是一个可能以及选过第iii种物品的子结果，所以可以直接采用递增循环。 参考自背包问题九讲 ↩︎ ","link":"https://zhangtyzzz.github.io/post/bei-bao-wen-ti-zong-jie/"}]}