<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zhangtyzzz.github.io/</id>
    <title>Tianyi的博客</title>
    <updated>2020-10-15T13:13:04.476Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zhangtyzzz.github.io/"/>
    <link rel="self" href="https://zhangtyzzz.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zhangtyzzz.github.io/images/avatar.png</logo>
    <icon>https://zhangtyzzz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Tianyi的博客</rights>
    <entry>
        <title type="html"><![CDATA[Pattern Two Pointers]]></title>
        <id>https://zhangtyzzz.github.io/post/pattern-two-pointers/</id>
        <link href="https://zhangtyzzz.github.io/post/pattern-two-pointers/">
        </link>
        <updated>2020-10-15T07:12:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="26-删除排序数组中的重复项"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除排序数组中的重复项</a></h2>
<blockquote>
<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
</blockquote>
<h3 id="解法">解法</h3>
<p>双指针从开头开始，指针分别为i,j，当指针指向的值相同时，j继续向前，i不动，直到不同了，i先前进一位，交换i和j的元素，j++。最后要个数所以返回++i。</p>
<pre><code class="language-java">class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length &lt;= 1) return nums.length;
        int i = 0,j = 1;
        while(j&lt;nums.length){
            while (j&lt;nums.length &amp;&amp; nums[j] == nums[i]){
                j++;
            }
            if(j&lt;nums.length){
                nums[++i] = nums[j];
                j++;
            }
        }
        return ++i;
    }
}
</code></pre>
<p>另一种写法</p>
<pre><code class="language-java">class Solution {
    public int removeDuplicates(int[] nums) {
        // nextNonDuplicate 初始为1，最开始检测其它元素是否与index为0处重复
        // 发现不重复了之后把nextNonDuplicate处的元素设为新元素，并自加1
        // 此时没必要最后自加1了，因为在赋值时已经进行了这项操作
        int nextNonDuplicate = 1;
        for (int i = 1; i &lt; nums.length; i++) {
            if(nums[nextNonDuplicate-1] != nums[i]){
                nums[nextNonDuplicate++] = nums[i];
            }
        }
        return nextNonDuplicate;
    }
}
</code></pre>
<h2 id="977-有序数组的平方"><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h2>
<blockquote>
<p>给定一个按非递减顺序排序的整数数组 <code>A</code>，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p>
</blockquote>
<h3 id="解法-2">解法</h3>
<p>最简单的就是求平方后排序，但是没有利用到该数组本身有序。采用双指针法，首先找到第一个非负整数，然后两个指针分别向左向右</p>
<pre><code class="language-java">class Solution {
    public int[] sortedSquares(int[] A) {
        int leftIdx = 0,rightIdx = A.length;
        int leftNum = 0,rightNum = 0;
        int ansIdx = 0;
        int[] ansArray = new int[A.length];
        for (int i = 0; i &lt; A.length; i++) {
            if(A[i] &gt;= 0 || i == A.length-1){
                leftIdx = i-1;
                rightIdx = i;
                break;
            }
        }
        while (leftIdx&gt;=0 &amp;&amp; rightIdx&lt;A.length){
            leftNum = A[leftIdx]*A[leftIdx];
            rightNum = A[rightIdx]*A[rightIdx];
            if(leftNum &lt;= rightNum){
                ansArray[ansIdx++] = leftNum;
                leftIdx--;
            }else {
                ansArray[ansIdx++] = rightNum;
                rightIdx++;
            }
        }
        while (leftIdx&gt;=0){
            leftNum = A[leftIdx]*A[leftIdx];
            ansArray[ansIdx++] = leftNum;
            leftIdx--;
        }
        while (rightIdx&lt;A.length){
            rightNum = A[rightIdx]*A[rightIdx];
            ansArray[ansIdx++] = rightNum;
            rightIdx++;
        }
        return ansArray;
    }
}
</code></pre>
<h2 id="15-三数之和"><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h2>
<blockquote>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<h3 id="解法-3">解法</h3>
<p>先对数组排序，然后遍历并使用双指针</p>
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        if(nums.length &lt; 3) return ans;
        Arrays.sort(nums);
        int leftIdx = 0,rightIdx = nums.length-1,tmpAns = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            // 如果最小的值已经大于0了，没必要继续循环了
            if(nums[i] &gt; 0) break;
            // 消去重复值，因为每次的nums[i]都会检测出所有与其匹配的结果
            if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]) continue;
            // 双指针
            leftIdx = i+1;
            rightIdx = nums.length-1;
            while(leftIdx &lt; rightIdx){
                // 根据当前的和调整指针的位置
                tmpAns = nums[i] + nums[leftIdx] + nums[rightIdx];
                if(tmpAns &gt; 0){
                    rightIdx--;
                }else if(tmpAns &lt; 0){
                    leftIdx++;
                }else {
                    ans.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[i],nums[leftIdx],nums[rightIdx])));
                    // 找到结果之后继续移动指针，因为一个i可能对应多个结果，此时注意去重
                    while(leftIdx &lt; rightIdx &amp;&amp; nums[leftIdx+1] == nums[leftIdx]){
                        leftIdx++;
                    }
                    while (leftIdx &lt; rightIdx &amp;&amp; nums[rightIdx-1] == nums[rightIdx]){
                        rightIdx--;
                    }
                    // 最后移动一下指针避免死循环，当前为0，移动左会导致结果大于0，移动右会导致小于0，都会进入上面的判断
                    rightIdx--;
                }
            }
        }
        return ans;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pattern Sliding Window]]></title>
        <id>https://zhangtyzzz.github.io/post/pattern-sliding-window/</id>
        <link href="https://zhangtyzzz.github.io/post/pattern-sliding-window/">
        </link>
        <updated>2020-09-27T21:02:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="209-长度最小的子数组"><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h3>
<blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
</blockquote>
<h4 id="解法">解法</h4>
<p>滑动窗口大小可变，每次添加一个元素进去，如果此时总和大于s，开始从窗口开头去除元素直到窗口总和不再大于s。</p>
<pre><code class="language-java">class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        int minLength = Integer.MAX_VALUE,windowStart = 0;
        int curSum = 0;
        for (int windowEnd = 0; windowEnd &lt; nums.length; windowEnd++) {
            curSum += nums[windowEnd];
            if(curSum &gt;= s){
                while(curSum - nums[windowStart] &gt;= s){
                    curSum -= nums[windowStart];
                    windowStart++;
                }
                minLength = Math.min(minLength,windowEnd - windowStart + 1);
            }
        }
        return minLength == Integer.MAX_VALUE ? 0 : minLength;
    }
}
</code></pre>
<h3 id="3-无重复字符的最长子串"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3>
<blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
</blockquote>
<h4 id="解法1">解法1</h4>
<p>使用HashSet记录当前滑动窗口内包含的元素，保证没有重复。出现HashSet中已有的元素时开始从左边缩减窗口。</p>
<pre><code class="language-java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        int maxLength = 0, windowStart = 0;
        HashSet&lt;Character&gt; helperSet = new HashSet&lt;Character&gt;();
        for (int windowEnd = 0; windowEnd &lt; s.length(); windowEnd++) {
            char endChar = s.charAt(windowEnd);
            while (helperSet.contains(endChar)){
                helperSet.remove(s.charAt(windowStart));
                windowStart ++ ;
            }
            helperSet.add(s.charAt(windowEnd));
            maxLength = Math.max(maxLength,windowEnd-windowStart+1);
        }
        return maxLength;
    }
}
</code></pre>
<h4 id="解法2">解法2</h4>
<p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-jie-suan-fa-3-wu-zhong-fu-zi-fu-de-zui-chang-z/">题解</a>里看到的另一种方法，使用HashMap，可以在有重复元素的时候不必一个个删除，直接移动窗口左边界</p>
<pre><code class="language-java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length(), ans = 0;
        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
        for (int end = 0, start = 0; end &lt; n; end++) {
            char alpha = s.charAt(end);
            if (map.containsKey(alpha)) {
                // 发现HashMap里有当前元素，检查它所在的位置，如果位置在start的左边，
                // 那说明当前窗口里并不包括包括这项元素，这里的加一是为了保证重复元素不在滑动窗口里
                // 因为HashMap只添加没有删除的操作，所以里边会包括当前窗口里没有的元素。
                start = Math.max(map.get(alpha) + 1, start);
            }
            ans = Math.max(ans, end - start + 1);
            // 把当前元素和对应的位置加入
            map.put(s.charAt(end), end);
        }
        return ans;
    }
}
</code></pre>
<h3 id="904-水果成篮"><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮</a></h3>
<blockquote>
<p>在一排树中，第 i 棵树产生 tree[i] 型的水果。<br>
你可以从你选择的任何树开始，然后重复执行以下步骤：</p>
<ol>
<li>把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。</li>
<li>移动到当前树右侧的下一棵树。如果右边没有树，就停下来。</li>
</ol>
<p>你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。</p>
</blockquote>
<h4 id="解法-2">解法</h4>
<p>两个篮子，每个只放一种，其实就是滑动窗口内保证只有两种。使用HashMap保证这一点。key存放元素，value存放个数。</p>
<pre><code class="language-java">class Solution {
    public int totalFruit(int[] tree) {
        int maxNumber = 0, windowStart = 0;
        Map&lt;Integer,Integer&gt; helperMap = new HashMap&lt;&gt;();
        for (int windowEnd = 0; windowEnd &lt; tree.length ; windowEnd++) {
            // 把元素加入HashMap中
            helperMap.put(tree[windowEnd],helperMap.getOrDefault(tree[windowEnd],0)+1);
            // 超过两个元素开始缩小窗口
            while (helperMap.size() &gt; 2){
                helperMap.put(tree[windowStart],helperMap.get(tree[windowStart])-1);
                if(helperMap.get(tree[windowStart]) == 0){
                    helperMap.remove(tree[windowStart]);
                }
                windowStart ++;
            }
            maxNumber = Math.max(maxNumber,windowEnd - windowStart +1);
        }
        return maxNumber;
    }
}
</code></pre>
<h3 id="424-替换后的最长重复字符"><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></h3>
<blockquote>
<p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 <em>k</em> 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p>
</blockquote>
<h4 id="解法1-2">解法1</h4>
<p>滑动窗口内除了重复次数最多的元素外，其它元素的数量不超过k个。使用HashMap存储重复次数。</p>
<pre><code class="language-java">class Solution {
    public int characterReplacement(String s, int k) {
        int maxLength = 0, maxRepeatLength = 0,windowStart = 0;
        char rightChar,leftChar;
        Map&lt;Character,Integer&gt; helperMap = new HashMap&lt;Character, Integer&gt;();
        for (int windowEnd = 0; windowEnd &lt; s.length(); windowEnd++) {
            rightChar = s.charAt(windowEnd);
            helperMap.put(rightChar,helperMap.getOrDefault(rightChar,0)+1);
            // 只需要检查新加入的重复次数是否超过历史最高次数即可
            maxRepeatLength = Math.max(maxRepeatLength,helperMap.get(rightChar));
            // 除了重复次数最多的之外，其它元素的个数超过k个
            if(windowEnd - windowStart +1 - maxRepeatLength &gt; k){
                /*
                缩小窗口，删除最左边的元素即可，此时maxRepeatLength的字母可能被删去，但是没有影响
                因为接下来新的元素如果和maxRepeatLength的元素相同，它将被正确更新
                如果不同，而且没有元素的重复次数超过maxRepeatLength,那么这个窗口并不可能使maxLength变得更大，
                我们最终要求的结果是maxLength，保证它正确即可。
                如果不同而且重复次数超过了maxLength，那maxRepeatLength也会被正确更新
                 */
                leftChar = s.charAt(windowStart);
                helperMap.put(leftChar,helperMap.get(leftChar) - 1);
                windowStart++;
            }
            maxLength = Math.max(maxLength,windowEnd - windowStart + 1);
        }
        return maxLength;
    }
}
</code></pre>
<h4 id="解法2-2">解法2</h4>
<p>不用哈希表，只有26个大写字母，用数组存储即可。</p>
<pre><code class="language-java">class Solution {
    public int characterReplacement(String s, int k) {
        int len = s.length();
        int[] count = new int[26];
        int start = 0, maxCount = 0, maxLength = 0;
        for (int end = 0; end &lt; len; end++) {
            maxCount = Math.max(maxCount, ++count[s.charAt(end) - 'A']);
            while (end - start + 1 - maxCount &gt; k) {
                count[s.charAt(start) - 'A']--;
                start++;
            }
            maxLength = Math.max(maxLength, end - start + 1);
        }
        return maxLength;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pattern Two Heaps]]></title>
        <id>https://zhangtyzzz.github.io/post/pattern-two-heaps/</id>
        <link href="https://zhangtyzzz.github.io/post/pattern-two-heaps/">
        </link>
        <updated>2020-09-02T20:37:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="295-find-median-from-data-stream"><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">295. Find Median from Data Stream</a></h3>
<blockquote>
<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>
<li>double findMedian() - 返回目前所有元素的中位数。</li>
</ul>
</blockquote>
<p><strong>解法：</strong></p>
<p>可以建立一个最大堆和一个最小堆，最大堆存储列表中较小的半部分，最小堆存储较大的那半部分。求中位数时就可以直接计算得出。</p>
<p>主要是在插入元素时，如果新的元素比最大堆的最大值要小，就应该加入最大堆，因为要扩展更小的那半部分。由于python中堆默认是最小堆，所以加了负号来建立最大堆。</p>
<p>元素插入完成之后检查两个堆的元素数量，如果某个堆元素数量比另一个多一个以上就需要平衡。</p>
<pre><code class="language-python">import heapq
class MedianFinder:

    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        # 最小堆存储较大的那一半
        self.min_heap = []
        # 最大堆用于存储数据集中较小的那一半
        self.max_heap = []
        

    def addNum(self, num: int) -&gt; None:
        if not self.min_heap and not self.max_heap:
            heapq.heappush(self.max_heap,-num)
        # 比如3,1,5,4 最大堆里存储的应该是-3，-1，最开始进入的是-3，-1&gt;=-3
        # 也就是说如果新的数据的反比最大堆里最大的还要大，说明新数据更小，要加入最大堆
        elif -num &gt;= self.max_heap[0]:
            heapq.heappush(self.max_heap,-num)
        else:
            heapq.heappush(self.min_heap,num)
        
        n1 = len(self.min_heap)
        n2 = len(self.max_heap)

        if n2-n1 &gt;= 2:
            heapq.heappush(self.min_heap,-heapq.heappop(self.max_heap))
        elif n1-n2&gt;=2:
            heapq.heappush(self.max_heap,-heapq.heappop(self.min_heap))

    def findMedian(self) -&gt; float:
        n1 = len(self.min_heap)
        n2 = len(self.max_heap)
        if n1 &gt; n2:
            return self.min_heap[0]
        elif n1 &lt; n2:
            return -self.max_heap[0]
        else:
            return (self.min_heap[0]-self.max_heap[0])/2
</code></pre>
<h3 id="480-sliding-window-median"><a href="https://leetcode-cn.com/problems/sliding-window-median/">480. Sliding Window Median</a></h3>
<blockquote>
<p>给你一个数组 nums，有一个大小为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。</p>
</blockquote>
<p><strong>解法：</strong></p>
<p>和上题类似，只是滑动窗口需要进行元素的删除操作，问题是删除元素之后重新对堆做平衡的复杂度是O(n)，可以看一下题解有没有更好的写法</p>
<pre><code class="language-python">from heapq import *
class Solution:
    def medianSlidingWindow(self, nums, k):
        max_heap = []
        min_heap = []

        def remove(num, heap):
            # 查找元素位置,交换到末位再删降低复杂度
            del_idx = heap.index(num)
            heap[-1], heap[del_idx] = heap[del_idx], heap[-1]
            heap.pop()
            # 这一步还是O(n)的复杂度，有点问题
            heapify(heap)
            return heap

        def find_mid(min_heap, max_heap):
            if len(max_heap) &gt; len(min_heap):
                return -max_heap[0]
            else:
                return (min_heap[0] - max_heap[0]) / 2

        def balance(min_heap,max_heap):
            n_max = len(max_heap)
            n_min = len(min_heap)

            if n_max - n_min &gt; 1:
                heappush(min_heap, -heappop(max_heap))
            # 这里是保证max_heap的数据量大于等于min_heap
            # 因为删除元素的时候max_heap可能被删除到空，
            # 此时添加元素会直接添加到max_heap里去，
            # 可能出现min_heap里的元素反而比max_heap里的小的情况
            elif n_min  &gt;  n_max:
                heappush(max_heap, -heappop(min_heap))
            return min_heap,max_heap

        ans = []
        for i, num in enumerate(nums):
            if not max_heap or -num &gt;= max_heap[0]:
                heappush(max_heap, -num)
            else:
                heappush(min_heap, num)
  
            min_heap,max_heap = balance(min_heap,max_heap)
            n_max = len(max_heap)
            n_min = len(min_heap)

            if n_max + n_min &gt; k:
                num_remove = nums[i - k]
                if -num_remove &gt;= max_heap[0]:
                    max_heap = remove(-num_remove, max_heap)
                else:
                    min_heap = remove(num_remove, min_heap)
                # 因为进行了删除操作，需要重新对堆做平衡
                min_heap, max_heap = balance(min_heap, max_heap)


            if i &gt;= k-1:
                ans.append(find_mid(min_heap, max_heap))

        return ans
</code></pre>
<h3 id="502-ipo"><a href="https://leetcode-cn.com/problems/ipo/">502. IPO</a></h3>
<blockquote>
<p>假设 力扣（LeetCode）即将开始其 IPO。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。<br>
给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。</p>
<p>总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。</p>
</blockquote>
<p><strong>解法：</strong></p>
<p>贪心算法，从能承受的项目里选择利润最高的那个。需要知道能承受的项目有什么，然后能承受的项目里利润最高的是哪些。同样可以用最大最小堆来做。首先把所有的项目所需的资本建立一个最小堆，然后逐个pop，把能承受的项目的利润建立一个最大堆，每次选择利润最大的那个项目。</p>
<pre><code class="language-python">from heapq import *
class Solution:
    def findMaximizedCapital(self, k, W, Profits, Capital):
        # 可以加速运算，如果初始可用资本就可以承受所有项目直接选择利润最大的k个即可
        if W &gt;= max(Capital):
            return W + sum(nlargest(k, Profits))
        # 资本最小堆和利润最大堆
        capital_minheap = []
        profit_maxheap = []

        # 首先构建资本最小堆
        for i in range(len(Capital)):
            # 注意把资本和对应的位置绑定，方便后续找对应利润
            heappush(capital_minheap,(Capital[i],i))
        # 初始可用资本
        available_capital = W
        # 最多k次
        for _ in range(k):
            # 找到当前可用资本下可以选择的所有项目，然后用他们的利润构建最大堆
            while capital_minheap and capital_minheap[0][0] &lt;= available_capital:
                capital,i = heappop(capital_minheap)
                # 构建利润最大堆
                heappush(profit_maxheap,-Profits[i])
            # 如果利润最大堆为空，说明当前资本什么都买不了，跳出
            if not profit_maxheap: break
            # 选择利润最大的项目，增加可用资本
            available_capital += -heappop(profit_maxheap)
        
        return available_capital
</code></pre>
<h3 id="436-find-right-interval"><a href="https://leetcode-cn.com/problems/find-right-interval/">436. Find Right Interval</a></h3>
<blockquote>
<p>给定一组区间，对于每一个区间 i，检查是否存在一个区间 j，它的起始点大于或等于区间 i 的终点，这可以称为 j 在 i 的“右侧”。</p>
<p>对于任何区间，你需要存储的满足条件的区间 j 的最小索引，这意味着区间 j 有最小的起始点可以使其成为“右侧”区间。如果区间 j 不存在，则将区间 i 存储为 -1。最后，你需要输出一个值为存储的区间值的数组。</p>
</blockquote>
<p><strong>解法1：</strong></p>
<p>因为要找的是当前终点对应的最小起点，所以直接对起点排序，然后二分查找起点的位置即可。对应代码</p>
<pre><code class="language-python">class Solution:
    def findRightInterval(self, intervals):
        # 记录每个区间对应的索引
        tmp_intervals = [(interval[0],i) for i,interval in enumerate(intervals)]
        # 按照起点排序
        left_interval = sorted(tmp_intervals,key=lambda x:x[0])
        n = len(intervals)
        # 二分查找函数
        def divide_find(val):
            i = 0
            j = n
            if left_interval[j-1][0] &lt; val: return -1
            while i&lt;j:
                mid = i+(j-i)//2
                if left_interval[mid][0] &gt; val:
                    j = mid
                elif left_interval[mid][0] &lt; val:
                    i = mid+1
                else:
                    return left_interval[mid][1]
            return left_interval[i][1]
        ans = []
        for interval in intervals:
            num_to_find = interval[1]
            ans.append(divide_find(num_to_find))
        return ans
</code></pre>
<p><strong>解法2：</strong></p>
<p>利用两个最大堆，一个最大堆记录起点，一个记录终点。从大到小寻找当前终点对应的起点</p>
<pre><code class="language-python">from heapq import *
class Solution:
    def findRightInterval(self, intervals):
        n = len(intervals)
        max_start = []
        max_end = []
        ans = [0] * n
        for i,interval in enumerate(intervals):
            heappush(max_start,(-interval[0],i))
            heappush(max_end,(-interval[1],i))
        for _ in range(n):
            # 当前的最大终点
            top_end,end_idx = heappop(max_end)
            # 先设定好找不到为-1
            start_idx = -1
            # 如果当前最大的起点比终点大，pop出来，直到当前最大起点比终点小为止
            # 最后pop出的起点就是对应的右区间
            while max_start and -max_start[0][0] &gt;= -top_end:
                top_start,start_idx = heappop(max_start)
            ans[end_idx] = start_idx
            # 因为当前的右区间可能还是其它终点的右区间，所以要把这个加回去
            # 多pop出来的就不可能是其它终点的右区间了
            # 因为更大的终点对应的右区间已经找出来，其它的终点右区间只会更小而不会更大
            if start_idx!=-1: heappush(max_start,(top_start,start_idx))
        return ans
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图]]></title>
        <id>https://zhangtyzzz.github.io/post/tu/</id>
        <link href="https://zhangtyzzz.github.io/post/tu/">
        </link>
        <updated>2020-08-18T18:01:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="课程表"><a href="https://leetcode-cn.com/problems/course-schedule/">课程表</a></h2>
<p><strong>leetcode 207题</strong><br>
你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p>
<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<h3 id="解法">解法<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h3>
<p>利用拓扑排序判断课程安排图是否存在环。</p>
<h4 id="bfs">BFS</h4>
<ol>
<li>统计课程安排图中每个节点的入度，生成 入度表 indegrees。</li>
<li>借助一个队列 queue，将所有入度为 0 的节点入队。(可以理解为，不需要先修课程的课)</li>
<li>当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点 pre：
<ul>
<li>并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点 cur 的入度 −1，即 indegrees[cur] -= 1。</li>
<li>如果入度 −1后邻接节点 cur 的入度为 0，说明 cur 所有的前驱节点已经被 “删除”，此时将 cur 入队。(也可以理解为，先修课程已经被完成)</li>
</ul>
</li>
<li>在每次 pre 出队时，执行 numCourses--；</li>
</ol>
<p>若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0。<br>
因此，拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排。</p>
<pre><code class="language-python">from collections import deque

class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:
        # 入度表
        indegrees = [0 for _ in range(numCourses)]
        # 邻接表
        adjacency = [[] for _ in range(numCourses)]
        queue = deque()
        for requre in prerequisites:
            pre = requre[1]
            cur = requre[0]
            # pre为cur的先修课程，所以cur的入度+1
            indegrees[cur] += 1
            # 存在pre指向cur的有向边，在邻接表中增加对应节点
            adjacency[pre].append(cur)
        for i,val in enumerate(indegrees):
            # 遍历入度表，把入度为0的节点入队
            if not val:
                queue.append(i) 
        while queue:
            pre_course = queue.popleft()
            # “删除”pre_course, pre_course对应的所有课程的入度减一
            course_list = adjacency[pre_course]
            for course in course_list:
                indegrees[course] -= 1
                # 假如存在环，比如[a,b],[b,a],[c,b] 第一次会把c入队，c的相邻节点为b，
                # b即使减一也不为0，因为和a组成了环，所以可以这么判断
                if not indegrees[course]:
                    queue.append(course)
            numCourses -= 1
        return not numCourses
</code></pre>
<h4 id="dfs">DFS</h4>
<ol>
<li>借助一个标志列表 flags，用于判断每个节点 i （课程）的状态：
<ul>
<li>未被 DFS 访问：i == 0；</li>
<li>已被其他节点启动的 DFS 访问：i == -1</li>
<li>已被当前节点启动的 DFS 访问：i == 1。</li>
</ul>
</li>
<li>对 numCourses 个节点依次执行 DFS，判断每个节点起步 DFS 是否存在环，若存在环直接返回 False。DFS 流程:
<ol>
<li>终止条件：
<ul>
<li>当 flag[i] == -1，说明当前访问节点已被其他节点启动的 DFS 访问，无需再重复搜索，直接返回 True。</li>
<li>当 flag[i] == 1，说明在本轮 DFS 搜索中节点 i 被第 2 次访问，即课程安排图有环 ，直接返回 False。</li>
</ul>
</li>
<li>将当前访问节点 i 对应 flag[i] 置 1，即标记其被本轮 DFS 访问过；</li>
<li>递归访问当前节点 i 的所有邻接节点 j，当发现环直接返回 False；</li>
<li>当前节点所有邻接节点已被遍历，并没有发现环，则将当前节点 flag 置为 −1 并返回 True</li>
</ol>
</li>
<li>若整个图 DFS 结束并未发现环，返回 True。</li>
</ol>
<pre><code class="language-python">class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:
        # 标志位
        flags = [0 for _ in range(numCourses)]
        # 邻接表
        adjacency = [[] for _ in range(numCourses)]
        
        for require in prerequisites:
            pre = require[1]
            cur = require[0]
            adjacency[pre].append(cur)

        def dfs(course):
            if flags[course] == -1:
                return True
            elif flags[course] == 1:
                return False
            flags[course] = 1
            # 遍历course的所有邻接节点
            for tmp_course in adjacency[course]:
                # 邻接节点里发现环就return False
                if not dfs(tmp_course):
                    return False
            flags[course] = -1
            return True

        for i in range(numCourses):
            # 任何一个节点发现环return False
            if not dfs(i):
                return False
        return True
</code></pre>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/ <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP和HTTPS总结]]></title>
        <id>https://zhangtyzzz.github.io/post/http-he-https/</id>
        <link href="https://zhangtyzzz.github.io/post/http-he-https/">
        </link>
        <updated>2020-07-19T14:12:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="http">HTTP</h2>
<h3 id="http协议特点">HTTP协议特点</h3>
<ul>
<li>支持客户/服务器模式</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。1.1后默认持续链接</li>
<li>无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。解决方法，Cookie和Session</li>
</ul>
<h3 id="http版本区别">HTTP版本区别</h3>
<figure data-type="image" tabindex="1"><img src="https://zhangtyzzz.github.io//post-images/1595322195233.png" alt="" loading="lazy"></figure>
<h3 id="请求报文和响应报文">请求报文和响应报文</h3>
<h4 id="请求报文">请求报文</h4>
<ul>
<li>请求行：请求方式，请求路径，协议版本</li>
<li>请求头：包含许多有关的客户端环境和请求正文的有用信息</li>
<li>空行：表示请求头已经结束，接下来的是请求正文</li>
<li>请求正文</li>
</ul>
<h4 id="响应报文">响应报文</h4>
<ul>
<li>状态行：状态码，状态码描述，协议版本</li>
<li>响应头：为响应报文添加一些信息</li>
<li>空行</li>
<li>响应正文</li>
</ul>
<h4 id="请求方式总结">请求方式总结</h4>
<table>
<thead>
<tr>
<th>方式名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>请求获取 Request-URI所标识的资源</td>
</tr>
<tr>
<td>POST</td>
<td>向 Request-URI发送数据</td>
</tr>
<tr>
<td>HEAD</td>
<td>请求获取由 Request-URI所标识的资源的响应信息报头</td>
</tr>
<tr>
<td>PUT</td>
<td>请求服务器存储一个资源，并用 Request-URI作为其标识</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除 Request-URI所标识的资源</td>
</tr>
<tr>
<td>TRACE</td>
<td>请求服务器回送收到的请求信息，主要用于测试或诊断</td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求使用隧道协议连接代理</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>请求查询服务器的性能，或者查询与资源相关的选项</td>
</tr>
</tbody>
</table>
<h4 id="请求头总结列举部分">请求头总结（列举部分）</h4>
<ol>
<li>通用首部：请求报文和响应报文均使用
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody>
</table>
</li>
<li>请求首部
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web认证信息</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（与If-Match相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体Byte的范围请求</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中URI的原始获取方</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP客户端程序的信息</td>
</tr>
</tbody>
</table>
</li>
<li>响应首部
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
</li>
<li>实体首部：针对请求报文和响应报文的实体部分使用的首部
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Allow</td>
<td>资源可支持的HTTP方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Length-</td>
<td>实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的URI</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型(<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME</a>)</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h4 id="状态码">状态码</h4>
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody>
</table>
<p>常见状态码：</p>
<ul>
<li>200：客户端请求被正常处理</li>
<li>301：请求的资源被永久分配了新的URI</li>
<li>302：请求的资源被临时分配了新的URI</li>
<li>403：服务器拒绝访问请求的资源</li>
<li>404：服务器无法找到请求的资源</li>
<li>500：服务器在执行请求时出错</li>
</ul>
<h4 id="get和post区别">GET和POST区别</h4>
<ol>
<li>幂等：一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。在正确实现的条件下，GET，HEAD，PUT和DELETE 等方法都是幂等的，而 POST 方法不是。所有的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/safe">safe</a> 方法也都是幂等的。<br>
GET幂等，一般用来查询信息；POST非幂等</li>
<li>参数存放位置
<ul>
<li>GET方法中，客户端把要发送的数据添加到URL后面（即把数据放到HTTP协议头中，GET是通过URL请求数据的），使用“？”连接，参数之间使用“&amp;”连接。注意：HTTP协议中并没有对URL长度进行限制，但是浏览器和服务器会对其限制！(Chrome是2MB)</li>
<li>POST是将需要传递的数据放到HTTP请求报文的消息体中（同样，协议未对此部分大小进行限制），不过传送的数据量比GET更大且安全性更高</li>
</ul>
</li>
<li>缓存<br>
大多数情况下GET可缓存，POST不可缓存</li>
</ol>
<h3 id="为什么说http协议无状态如何保持状态">为什么说HTTP协议无状态？如何保持状态</h3>
<p>无状态协议指每个请求都是一个全新的请求，与之前的所有请求都无关。也就是说它的每个请求是完全独立的。比如第一次访问一个购物网站需要登陆，第二次访问也同样需要登录。</p>
<ul>
<li>优点：不必分配大量资源去保存状态，可以减少CPU和内存的消耗</li>
<li>缺点： 如果后续处理需要前面的信息，客户端必须重传，可能导致每次连接传送的数据量增大。<br>
解决方法：Cookie和Session</li>
</ul>
<h3 id="cookie和session">Cookie和Session</h3>
<h4 id="cookie">Cookie</h4>
<p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。保存在客户端<br>
<img src="https://zhangtyzzz.github.io//post-images/1595343812735.png" alt="" loading="lazy"><br>
<img src="https://zhangtyzzz.github.io//post-images/1595343826016.png" alt="" loading="lazy"></p>
<p>报文</p>
<pre><code class="language-http">*请求报文：首部字段内没有Cookie的相关信息
GET /reader/ HTTP/1.1
Host: hackr.jp

*响应报文：服务端生成Cookie信息
HTTP/1.1 200 OK
Date: Thu, 12 Jul 2012 07:12:20 GMT
Server: Apache
＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,
10-Oct-12 07:12:20 GMT＞
Content-Type: text/plain; charset=UTF-8

*之后的请求报文：发送保存的Cookie信息
GET /image/ HTTP/1.1
Host: hackr.jp
Cookie: sid=1342077140226724
</code></pre>
<h4 id="session">Session</h4>
<p>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。<br>
当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否包含了一个session标识(session id)，如果已经包含一个 session id则说明以前已经为此客户创建过session，服务器就按照session id把这个检索出来使用（如果检索不到，可能会新建一个，这种情况可能出现在服务端已经删除了该用户对应的 session对象，但用户人为地在请求的URL后面附加上一个JSESSION的参数）<br>
如果客户请求不包含session id，则为此客户创建一个session并且生成一个与此相关联的session id，这个session id将在本次响应中返回给客户端保存，客户端再次发送请求时会把session id带上。</p>
<h4 id="区别">区别</h4>
<ul>
<li>存放位置
<ul>
<li>Cookie存放在客户端</li>
<li>Session存放在服务器</li>
</ul>
</li>
<li>存取方式
<ul>
<li>Cookie只能存储ASCII字符串，要存二进制数据之类的需要先编码</li>
<li>Session可以存储任意格式</li>
</ul>
</li>
<li>安全性(隐私策略)
<ul>
<li>Cookie存放在客户端，对客户端可见。有被客户端程序修改的风险</li>
<li>Session存放在服务端，对客户端透明，不会泄露敏感信息</li>
</ul>
</li>
<li>有效期
<ul>
<li>Cookie可以设置较长的有效期，这样就可以保存很长的时间，平时的关闭浏览器即失效的Cookie叫做会话Cookie，存放在内存中</li>
<li>大部分情况下通过会话Cookie存放session id，关闭浏览器后，Cookie消失，原来的Session id也消失，所以再次连接到服务器无法找到原来的Session。因此服务器为Session设置一个失效时间，距离客户端上次使用Session的时间超过了这个失效时间后，服务器会删除Session来节省存储空间。</li>
</ul>
</li>
<li>对服务器的压力
<ul>
<li>Cookie：保存在客户端，不占用服务器内存</li>
<li>Session：如果并发访问的用户非常多，会产生大量Session，耗费大量内存</li>
</ul>
</li>
</ul>
<h2 id="https">HTTPS</h2>
<h3 id="http的缺点">HTTP的缺点：</h3>
<ul>
<li>通信使用明文(不加密)，内容可能被窃听
<ul>
<li><strong>加密方式</strong></li>
<li>通信加密：可以通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。</li>
<li>内容加密：对HTTP协议传输内容本身加密。客户端需要对HTTP报文进行加密处理后再发送请求。为了做到有效的内容加密，前提是客户端和服务器同时具备加密和解密机制。（该方法不同于SSL或TLS将整个通信线路加密处理，所以内容有篡改的风险）</li>
</ul>
</li>
<li>不验证通信方的身份，可能遭到伪装
<ul>
<li><strong>确定通信方的方法</strong></li>
<li>SSL提供了一种叫证书的方法，可以用来确定通信方。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。</li>
</ul>
</li>
<li>无法证明报文完整性，可能遭到篡改
<ul>
<li>这里不要把TCP的可靠性和完整性混淆了，TCP的检验和字段可以抵抗传输错误，但是是有可能被故意修改的，修改者可以重新计算校验和</li>
<li>有使用HTTP协议确定报文完整性的方法，事实上并不可靠，常用的是MD5（单向函数生成的散列值）和SHA-1等散列值校验方法，及用来确认文件的数字签名方法。可惜的是如果MD5本身被改写，用户没有办法意识到。</li>
</ul>
</li>
</ul>
<h3 id="https层次图">HTTPS层次图</h3>
<figure data-type="image" tabindex="2"><img src="https://imgedu.lagou.com/51491d85-ad5a-4ff8-8e22-2184a0d93b80.jpg" alt="" loading="lazy"></figure>
<h3 id="https缺点">HTTPS缺点</h3>
<ul>
<li>通信慢：同HTTP协议相比，网络负载会变慢，因为除去TCP连接、HTTP请求与响应外，还必须处理SSL、TSL通信，导致通信量的增加。</li>
<li>SSL必须进行加密处理：在服务器端和客户端都要通过加密、解密进行数据的安全处理，因此从结果而言，比起HTTP会更多地消耗服务器和客户端的硬件资源，导致负载增强。</li>
</ul>
<h3 id="加密技术">加密技术</h3>
<ul>
<li>共享密钥加密：加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</li>
<li>公开密钥加密：使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</li>
<li>尽管公开密钥加密更加安全，但是处理速度较慢，因此HTTPS采取的是二者并用的混合加密模式，如果密钥可以安全交换，可以仅使用共享密钥加密。<br>
<img src="https://zhangtyzzz.github.io//post-images/1595421591786.png" alt="" loading="lazy"></li>
</ul>
<p>公开密钥仍存在一些问题，就是无法证明公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。<br>
<img src="https://zhangtyzzz.github.io//post-images/1595421860965.png" alt="" loading="lazy"></p>
<h3 id="通信步骤">通信步骤</h3>
<figure data-type="image" tabindex="3"><img src="https://zhangtyzzz.github.io//post-images/1595425097814.png" alt="" loading="lazy"></figure>
<ol>
<li>ClientHello之前有TCP三次握手</li>
<li>客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL\TLS 版本、随机数(用于生产会话密钥)、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</li>
<li>服务器发出响应 ServerHello到ServerHello Done，包括确认SSL/TLS版本、服务器生成的随机数，确认的加密组件，服务器的数字证书</li>
<li>客户端收到响应后，通过浏览器或者操作系统中的CA公钥，确认服务器数字证书的真实性，如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
<ol>
<li>一个随机数（pre-master key）。该随机数会被服务器公钥加密。</li>
<li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li>
<li>客户端握手结束通知，表示客户端的握手阶段已经结束。</li>
<li>此时整个握手阶段已经有了三个随机数，服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。</li>
</ol>
</li>
<li>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发出最后的信息，这一段信息用服务端私钥加密：
<ol>
<li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li>
<li>服务器握手结束通知</li>
</ol>
</li>
<li>至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</li>
</ol>
<h3 id="证书验证">证书验证<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h3>
<p>证书里包含：签发者，证书用途，到期时间，公钥，hash算法等等。CA对以上内容做哈希处理，然后用自己的私钥加密，得到数字签名附在证书末尾。<br>
客户端在收到服务器的证书后，找到对应的CA公钥，解密证书，得到数字签名HASH1<br>
客户端按照相同的hash算法计算一个哈希值，HASH2，如果HASH1==HASH2，认证通过，否则不通过</p>
<p>参考文章和书籍<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>参考自知乎：https://www.zhihu.com/question/52493697 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>https://blog.csdn.net/ITermeng/article/details/78517364，图解HTTP <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python多线程和GIL]]></title>
        <id>https://zhangtyzzz.github.io/post/python-duo-xian-cheng-he-gil/</id>
        <link href="https://zhangtyzzz.github.io/post/python-duo-xian-cheng-he-gil/">
        </link>
        <updated>2020-07-18T19:06:44.000Z</updated>
        <content type="html"><![CDATA[<p><strong>多线程的简单实现</strong></p>
<pre><code class="language-python">import threading
import time


def task1(name):
    print('Task %s start at %s' % (name, time.ctime()))
    time.sleep(2)
    print(&quot;Task %s end at %s&quot; % (name, time.ctime()))


def task2(name):
    print('Task %s start at %s' % (name, time.ctime()))
    time.sleep(4)
    print(&quot;Task %s end at %s&quot; % (name, time.ctime()))


if __name__ == '__main__':
    t1 = threading.Thread(target=task1, args=('thread1',))  # Thread是一个类，实例化产生t1对象，这里就是创建了一个线程对象t1
    t1.start()  # 线程执行
    t2 = threading.Thread(target=task2, args=('thread2',))  # 这里就是创建了一个线程对象t2
    t2.start()

    print(&quot;程序结束=====================&quot;)
</code></pre>
<p>输出为</p>
<blockquote>
<p>Task thread1 start at Sun Jul 19 15:13:06 2020<br>
Task thread2 start at Sun Jul 19 15:13:06 2020<br>
程序结束=====================<br>
Task thread2 end at Sun Jul 19 15:13:08 2020<br>
Task thread1 end at Sun Jul 19 15:13:08 2020<br>
Process finished with exit code 0</p>
</blockquote>
<p>“程序结束”所输出的位置并不是最后，这是因为主线程和另外两个线程是并行的，但是主线程等非守护子线程结束之后才会退出。如果希望把程序结束打印在最后，就使用join()，join的作用是等待线程结束。</p>
<p>代码：</p>
<pre><code class="language-python">import threading
import time


def task1(name):
    print('Task %s start at %s' % (name, time.ctime()))
    time.sleep(2)
    print(&quot;Task %s end at %s&quot; % (name, time.ctime()))


def task2(name):
    print('Task %s start at %s' % (name, time.ctime()))
    time.sleep(4)
    print(&quot;Task %s end at %s&quot; % (name, time.ctime()))


if __name__ == '__main__':
    t1 = threading.Thread(target=task1, args=('thread1',))  # Thread是一个类，实例化产生t1对象，这里就是创建了一个线程对象t1
    t1.start()  # 线程执行
    t2 = threading.Thread(target=task2, args=('thread2',))  # 这里就是创建了一个线程对象t2
    t2.start()

    t2.join()
    t1.join()
    print(&quot;程序结束=====================&quot;)
</code></pre>
<p>输出为</p>
<blockquote>
<p>Task thread1 start at Sun Jul 19 15:20:46 2020<br>
Task thread2 start at Sun Jul 19 15:20:46 2020<br>
Task thread1 end at Sun Jul 19 15:20:48 2020<br>
Task thread2 end at Sun Jul 19 15:20:50 2020<br>
程序结束=====================<br>
Process finished with exit code 0</p>
</blockquote>
<p>守护线程：是一种提供服务的线程，为用户线程提供服务，当所有的用户线程死掉后，会自动终止。<br>
分别设置t1和t2为守护线程，查看输出结果。</p>
<pre><code class="language-python">import threading
import time


def task1(name):
    print('Task %s start at %s' % (name, time.ctime()))
    time.sleep(2)
    print(&quot;Task %s end at %s&quot; % (name, time.ctime()))


def task2(name):
    print('Task %s start at %s' % (name, time.ctime()))
    time.sleep(4)
    print(&quot;Task %s end at %s&quot; % (name, time.ctime()))


if __name__ == '__main__':
    t1 = threading.Thread(target=task1, args=('thread1',))  # Thread是一个类，实例化产生t1对象，这里就是创建了一个线程对象t1
    t1.setDaemon(True) #设置t1为守护线程
    t1.start()  # 线程执行
    t2 = threading.Thread(target=task2, args=('thread2',))  # 这里就是创建了一个线程对象t2
    # t2.setDaemon(True) #设置t2为守护线程
    t2.start()
</code></pre>
<p>t1为守护线程时：</p>
<blockquote>
<p>Task thread1 start at Sun Jul 19 15:31:04 2020<br>
Task thread2 start at Sun Jul 19 15:31:04 2020<br>
Task thread1 end at Sun Jul 19 15:31:06 2020<br>
Task thread2 end at Sun Jul 19 15:31:08 2020<br>
Process finished with exit code 0</p>
</blockquote>
<p>t2为守护线程时:</p>
<blockquote>
<p>Task thread1 start at Sun Jul 19 15:30:42 2020<br>
Task thread2 start at Sun Jul 19 15:30:42 2020<br>
Task thread1 end at Sun Jul 19 15:30:44 2020<br>
Process finished with exit code 0</p>
</blockquote>
<p>程序里设置的t2是sleep 4s，在t2为守护线程时，t1执行完毕之后，主线程直接结束了，没有等待t2结束。(注意这里没有join)<br>
程序的运行时间从顺序执行需要的6s降低到了4s，但这是由cpu并发实现的，而非真正的多CPU并行。<br>
<strong>什么是并发和并行</strong></p>
<ul>
<li>
<p>并发：一个系统具有处理多个任务的能力<br>
<img src="https://hackernoon.com/photos/ZbqyG0GzLmVkwsYNyBRB9kTk5DR2-83212cm" alt="" loading="lazy"><br>
上图是一个没有并行的并发，可以同时处理收款和下单的请求，这就是并发了，但是这不是并行。</p>
</li>
<li>
<p>并行：一个系统具有同时处理多个任务的能力<br>
<img src="https://hackernoon.com/photos/ZbqyG0GzLmVkwsYNyBRB9kTk5DR2-gwnd122h" alt="" loading="lazy"><br>
上图则是并行，由两个员工分别处理收款和下单</p>
</li>
</ul>
<p>如何看出python的多线程其实是并行而不是并发呢，以下面的例子为例</p>
<pre><code class="language-python">import threading
import time


def countdown():
    x = 500000000
    while x &gt; 0:
        x -= 1


# Implementation 1: Multi-threading
def implementation_1():
    thread_1 = threading.Thread(target=countdown)
    thread_2 = threading.Thread(target=countdown)
    start = time.time()
    print('Task start')
    thread_1.start()
    thread_2.start()
    thread_1.join()
    thread_2.join()
    print('Task use %s seconds' % (time.time() - start))


# Implementation 2: Run in serial
def implementation_2():
    start = time.time()
    print('Task start')
    countdown()
    countdown()
    print('Task use %s seconds' % (time.time() - start))

implementation_1()
implementation_2()
</code></pre>
<p>第一种执行方式为多线程，第二种为串行，输出结果如下</p>
<blockquote>
<p>Task start<br>
Task use 76.96876907348633 seconds<br>
Task start<br>
Task use 78.24504065513611 seconds</p>
</blockquote>
<p>可以看出，两种方式的时间基本没有差别，如果是真正的并行，那么多线程执行的速度应该为串行的二倍。其中的原因就在于python的GIL(Global Interpreter Lock)全局解释器锁。引入GIL的原因是为了防止多个线程同时访问某个python对象，也就是避免读写冲突。<br>
以上面的代码为例，真正的运行方式如下:<br>
<img src="https://hackernoon.com/photos/ZbqyG0GzLmVkwsYNyBRB9kTk5DR2-7719p12h5" alt="" loading="lazy"><br>
线程运行前要请求GIL，当一个线程运行时，其它线程必须等待它释放GIL。线程在阻塞(比如IO阻塞)或者到达轮询时间之后会释放GIL，其它线程继续运行，所以Python的多线程在同一时间仅有一个线程在运行。那么为什么最开始的代码中时间减少了呢，因为我们使用了sleep，相当于遇到了阻塞，在等待，此时切换到另外的线程运行其它的任务，这样时可以节省时间增加性能的。</p>
<p>因此，对于计算密集型的功能，其实用多线程反而可能影响性能，因为线程切换也是需要消耗时间和资源的，线程计算时没有等待，此时的切换是没有意义的。<br>
对于IO密集型的任务，使用多线程效果更好。</p>
<p>参考文章<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>https://juejin.im/post/5cc668d4f265da03904c21e7 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>https://hackernoon.com/concurrent-programming-in-python-is-not-what-you-think-it-is-b6439c3f3e6a <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络各层设备]]></title>
        <id>https://zhangtyzzz.github.io/post/wang-luo-ge-ceng-she-bei/</id>
        <link href="https://zhangtyzzz.github.io/post/wang-luo-ge-ceng-she-bei/">
        </link>
        <updated>2020-07-18T14:13:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="物理层">物理层</h2>
<p><strong>中继器</strong>：在bit级别将信号放大再调整传输，防止远距离传输的信号衰减。<br>
<strong>中继集线器</strong>：有的中继器可以提供多端口服务，这种中继器被称为中继集线器，或集线器、Hub(现在说的Hub更多指数据链路层的交换式集线器)</p>
<h2 id="数据链路层">数据链路层</h2>
<p><strong>网桥</strong>：可以识别数据帧，把数据帧临时存储于内存中，再重新生成新的数据帧转发给另一个网段。因为可以存储数据帧，所以可以连接传输速率不同的数据链路。通过CRC校验检查数据是否损坏，如果损坏就丢弃，避免发送给其他网段。能通过地址自学机制和过滤功能控制网络流量。<br>
工作步骤：</p>
<ol>
<li>当数据帧沿着网络介质到达时，网桥会将该帧中携带的目的MAC地址与包含在它的MAC地址表进行比较</li>
<li>如果网桥断定数据帧的目的MAC地址与源的MAC地址在同一分段，那么它就不会将数据帧转发到其他网络分段，即为过滤</li>
<li>如果网桥断定数据帧的目的MAC地址与源的MAC地址不在同一分段，则把它转发到合适的网络分段</li>
<li>如果目的MAC地址是网桥所不知道的，则把该数据帧广播到网络中除发送该帧的设备以往的所有设备上。这个过程称为泛洪。</li>
</ol>
<p><strong>交换集线器</strong>：可以算是网桥的一种，连接电缆的每个端口都可以提供网桥的功能。</p>
<h2 id="网络层">网络层</h2>
<p><strong>路由器</strong>：为经过的每个IP数据包选择一条最佳传输路径，并将数据有效的传输到目的节点。网桥根据MAC地址进行处理，路由根据IP地址进行处理。</p>
<h2 id="应用层">应用层</h2>
<p><strong>网关</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：OSI参考模型中负责把传输层到应用的数据进行转换和转发的设备。<br>
举例：互联网邮件与手机邮件之间的转换服务。手机邮件有时可能会与互联网邮件互不兼容，这是由于它们在表示层和应用层中的“电子邮件协议”互不相同所导致的。<br>
那么，为什么连到互联网的电脑与手机之间能够互发电子邮件呢？如图所示，互联网与手机之间设置了一道网关。网关负责读取完各种不同的协议后，对它们逐一进行合理的转换，再将相应的数据转发出去。这样一来即使应用的是不同电子邮件的协议，计算机与手机之间也能互相发送邮件。<br>
<img src="https://zhangtyzzz.github.io//post-images/1595148581365.png" alt="" loading="lazy"></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>图解TCP IP <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[01背包和完全背包问题]]></title>
        <id>https://zhangtyzzz.github.io/post/01-bei-bao-he-wan-quan-bei-bao-wen-ti/</id>
        <link href="https://zhangtyzzz.github.io/post/01-bei-bao-he-wan-quan-bei-bao-wen-ti/">
        </link>
        <updated>2020-07-11T08:28:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-01背包问题">1. 01背包问题<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h2>
<p><strong>容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>的背包，有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>件物品，每个物品的价值分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，占用空间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，如何放可以使价值总和最大</strong><br>
状态转移方程：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>v</mi><mo>]</mo><mo>=</mo><mi mathvariant="normal">max</mi><mo>⁡</mo><mo>{</mo><mi>F</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mo>]</mo><mo separator="true">,</mo><mi>F</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mo>−</mo><msub><mi>C</mi><mi>i</mi></msub><mo>]</mo><mo>+</mo><msub><mi>W</mi><mi>i</mi></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">F [ i , v ] = \operatorname { max } \{ F [ i - 1 , v ] , F [ i - 1 , v - C _ { i } ] + W _ { i } \}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>v</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">F[i,v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>表示把前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>件放到容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>的背包里可以获得的最大价值，可以分为两种情况分析</p>
<ul>
<li>如果放了第i件物品，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>v</mi><mo>]</mo><mo>=</mo><mi>F</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mo>−</mo><msub><mi>C</mi><mi>i</mi></msub><mo>]</mo><mo>+</mo><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">F[i,v] = F[i-1,v-C_i]+W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，也就是把问题转换为前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>件，放在容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>−</mo><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v-C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的背包里的最大价值，加上第i件的价值。</li>
<li>如果不放第i件物品，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>v</mi><mo>]</mo><mo>=</mo><mi>F</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">F[i,v] = F[i-1,v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>，问题变为前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>件，放在容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>的背包里</li>
</ul>
<p>因为要取最大价值，所以取二者间更大的一种方案</p>
<p>伪代码：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>F</mi><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>0..</mn><mi>V</mi><mo>]</mo><mo>←</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> for </mtext><mi>i</mi><mo>←</mo><mn>1</mn><mtext> to </mtext><mi>N</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mspace width="1em"/><mtext> for </mtext><mi>v</mi><mo>←</mo><msub><mi>C</mi><mi>i</mi></msub><mtext> to </mtext><mi>V</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mspace width="2em"/><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>v</mi><mo>]</mo><mo>←</mo><mi mathvariant="normal">max</mi><mo>⁡</mo><mo>{</mo><mi>F</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mo>]</mo><mo separator="true">,</mo><mi>F</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mo>−</mo><msub><mi>C</mi><mi>i</mi></msub><mo>]</mo><mo>+</mo><msub><mi>W</mi><mi>i</mi></msub><mo>}</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\left. \begin{array} { l } { F [ 0,0 . . V ] \leftarrow 0 } \\ { \text { for } i \leftarrow 1 \text { to } N } \\  { \quad\text { for } v \leftarrow C _ { i } \text { to } V } \\ { \qquad F [ i , v ] \leftarrow \operatorname { max } \{ F [ i - 1 , v ] , F [ i - 1 , v - C _ { i } ] + W _ { i } \} } \end{array} \right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.800000000000001em;vertical-align:-2.1500000000000004em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord text"><span class="mord"> for </span></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mord text"><span class="mord"> to </span></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord"> for </span></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> to </span></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mspace" style="margin-right:2em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>例题及python代码：</p>
<blockquote>
<p><a href="https://www.lintcode.com/problem/backpack/description">在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]</a></p>
</blockquote>
<pre><code class="language-python">class Solution:
    &quot;&quot;&quot;
    @param m: An integer m denotes the size of a backpack
    @param A: Given n items with size A[i]
    @return: The maximum size
    &quot;&quot;&quot;
    def backPack(self, m, A):
        dp = [[0]*(len(A)+1) for i in range(m+1)]
               
        for j,data in enumerate(A):
            # i is current size 
            for i in range(1, m + 1):
                if i&gt;= data:
                    # j is from 0 to len(A)-1
                    # in our array dp[i][1] means use first item
                    # so here use j+1
                    dp[i][j+1] = max(dp[i][j],dp[i-data][j]+data)
                else:
                    dp[i][j+1] = dp[i][j]
        return dp[-1][-1]
</code></pre>
<h3 id="优化空间复杂度">优化空间复杂度</h3>
<p>使用一个一维数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mn>0</mn><mo>…</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">F[0\dotso V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>实现优化<br>
在例题中，假如背包大小为5，物品大小为3、4、2，列出表格如下</p>
<table>
<thead>
<tr>
<th>size</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>4</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>4</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<p>以物品大小为4，背包大小为5举例，我们会参考物品大小为3、背包大小为5和物品大小为3、背包大小为5-4=1的格子，也就是说我们在更新数据的时候参考的是上一行的以及左边的数据。那么我们可以使用一个一维数组存储之前的状态，在更新时，直接在当前的数组基础上更新。由于我们参考了左边的数据，所以我们在更新数据时，要从右向左更新，否则更新到后面的时候，前面的数据就不再是之前的状态，而是更新后的数据，就会出现错误。也可以理解为倒序是为了保证第i 次循环中的状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>v</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">F[i,v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>是由状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mo>−</mo><msub><mi>C</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">F[i-1,v- C_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 递推而来，这可以保证每件物品只选一次。</p>
<p>伪代码：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>F</mi><mo>[</mo><mn>0</mn><mo>…</mo><mi>V</mi><mo>]</mo><mo>←</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> for </mtext><mi>i</mi><mo>←</mo><mn>1</mn><mtext> to </mtext><mi>N</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mspace width="1em"/><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> for </mtext><mi>v</mi><mo>←</mo><mi>V</mi><mtext> to </mtext><msub><mi>C</mi><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mspace width="2em"/><mi>F</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>←</mo><mi mathvariant="normal">max</mi><mo>⁡</mo><mo>{</mo><mi>F</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo separator="true">,</mo><mi>F</mi><mo>[</mo><mi>v</mi><mo>−</mo><msub><mi>C</mi><mi>i</mi></msub><mo>]</mo><mo>+</mo><msub><mi>W</mi><mi>i</mi></msub><mo>}</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\left. \begin{array} { l } { F [ 0 \ldots V ] \leftarrow 0 } \\ { \text { for } i \leftarrow 1 \text { to } N } \\ { \quad \left. \begin{array}{l}{ \text { for } v \leftarrow V \text { to } C _ { i } }\\{\qquad F [ v ] \leftarrow \operatorname { max } \{ F [ v ] , F [ v - C _ { i } ] + W _ { i } \} }\end{array} \right. } \end{array} \right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.800000000000001em;vertical-align:-2.1500000000000004em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-5.260000000000001em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span style="top:-4.06em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mord text"><span class="mord"> for </span></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mord text"><span class="mord"> to </span></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mspace" style="margin-right:1em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord text"><span class="mord"> for </span></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord text"><span class="mord"> to </span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mspace" style="margin-right:2em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>python代码</p>
<pre><code class="language-python">class Solution:
    &quot;&quot;&quot;
    @param m: An integer m denotes the size of a backpack
    @param A: Given n items with size A[i]
    @return: The maximum size
    &quot;&quot;&quot;
    def backPack(self, m, A):
        # size from 0 to m
        dp = [0 for i in range(m+1)]
        # first time just use item 1
        # second time based of first time
        for data in A:
            for i in range(m, 0, -1):
                if i&gt;= data:
                    # dp[i-data],dp[i] use new item or not
                    dp[i] = max(dp[i],dp[i-data]+data)
        return dp[-1]
</code></pre>
<h2 id="2-完全背包问题">2. 完全背包问题</h2>
<p><strong>有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 种物品和一个容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> 的背包，每种物品都有无限件可用。放入第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 种物品<br>
的费用是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，价值是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。求解：将哪些物品装入背包，可使这些物品的耗费的费用总<br>
和不超过背包容量，且价值总和最大。</strong></p>
<p>由于每种物品有无限件，所以它可以取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mtext> ⁣</mtext><mo>⋯</mo><mi>V</mi><mi mathvariant="normal">/</mi><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">0\dotsi V/C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:-0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>件，采取之前01背包的思路来写状态转移方程：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>v</mi><mo>]</mo><mo>=</mo><mi mathvariant="normal">max</mi><mo>⁡</mo><mo>{</mo><mi>F</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mo>−</mo><mi>k</mi><msub><mi>C</mi><mi>i</mi></msub><mo>]</mo><mo>+</mo><mi>k</mi><msub><mi>W</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mn>0</mn><mo>≤</mo><mi>k</mi><msub><mi>C</mi><mi>i</mi></msub><mo>≤</mo><mi>v</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">F [ i , v ] = \operatorname { max } \{ F [ i - 1 , v - k C _ { i } ] + k W _ { i } | 0 \leq k C _ { i } \leq v \}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">}</span></span></span></span></span></p>
<p>求解状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>v</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">F[i,v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span> 的时间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mfrac><mi>v</mi><msub><mi>C</mi><mi>i</mi></msub></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\frac{v}{C_i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1951em;vertical-align:-0.44509999999999994em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.07153em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>，总的复杂度可以认为是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>V</mi><mo>∑</mo><mfrac><mi>V</mi><msub><mi>C</mi><mi>i</mi></msub></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">O(NV\sum \frac{V}{C_i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.317431em;vertical-align:-0.44509999999999994em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.07153em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>，是比较大的。</p>
<p><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>V</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(VN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>的算法</strong><br>
伪代码</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>F</mi><mo>[</mo><mn>0..</mn><mi>V</mi><mo>]</mo><mo>←</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> for </mtext><mi>i</mi><mo>←</mo><mn>1</mn><mtext> to </mtext><mi>N</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mspace width="1em"/><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> for </mtext><mi>v</mi><mo>←</mo><msub><mi>C</mi><mi>i</mi></msub><mtext> to </mtext><mi>V</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mspace width="2em"/><mi>F</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>←</mo><mi mathvariant="normal">max</mi><mo>⁡</mo><mo>(</mo><mi>F</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo separator="true">,</mo><mi>F</mi><mo>[</mo><mi>v</mi><mo>−</mo><msub><mi>C</mi><mi>i</mi></msub><mo>]</mo><mo>+</mo><msub><mi>W</mi><mi>i</mi></msub><mo>)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\left. \begin{array} { l } { F [ 0 . . V ] \leftarrow 0 } \\ { \text { for } i \leftarrow 1 \text { to } N } \\ { \quad \left. \begin{array}{l}{ \text { for } v \leftarrow C _ { i } \text { to } V }\\{\qquad F [ v ] \leftarrow \operatorname { max } ( F [ v ] , F [ v - C _ { i } ] + W _ { i } ) }\end{array} \right. } \end{array} \right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.800000000000001em;vertical-align:-2.1500000000000004em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-5.260000000000001em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span style="top:-4.06em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mord text"><span class="mord"> for </span></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mord text"><span class="mord"> to </span></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mspace" style="margin-right:1em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord text"><span class="mord"> for </span></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> to </span></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mspace" style="margin-right:2em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>与01背包优化空间复杂度后的代码区别仅有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>的循环次序不同，之前01背包中倒序的原因是为了保证每个物品只能被选择一次，如果正序，每件物品可以被选择多次，现在需要的正是一个可能以及选过第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>种物品的子结果，所以可以直接采用递增循环。</p>
<p>另一种思考方式：<br>
对第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>件物品，可以取，也可以不取，状态转移方程可以写成</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>v</mi><mo>]</mo><mo>=</mo><mi mathvariant="normal">max</mi><mo>⁡</mo><mo>{</mo><mi>F</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mo>]</mo><mo separator="true">,</mo><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>v</mi><mo>−</mo><msub><mi>C</mi><mi>i</mi></msub><mo>]</mo><mo>+</mo><msub><mi>W</mi><mi>i</mi></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">F [ i , v ] = \operatorname { max } \{ F [ i - 1 , v ] , F [ i  , v - C _ { i } ] + W _ { i } \}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span></p>
<p>与01背包不同的是，取第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>件物品时，这里是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">F[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，01背包则是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">F[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。同样，第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>行的状态和第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>行以及第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>行前边有关，由此可以化简成上述<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>V</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(VN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>伪代码</p>
<p>例题：</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/coin-change/">给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</a></p>
</blockquote>
<p>python代码</p>
<pre><code class="language-python">class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:
        if not amount: return 0
        dp = [float('inf')]*(amount+1)
        dp[0] = 0
        for coin in coins:
            for i in range(amount+1):
                if i &gt;= coin:
                    dp[i] = min(dp[i],dp[i-coin]+1)
       
        return dp[-1] if dp[-1]!=float('inf') else -1
</code></pre>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>参考自<a href="https://github.com/tianyicui/pack">背包问题九讲</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
</feed>